isSolution :: [String] -> Bool
isSolution (_:_:(_:_:_:_:['X','X']):_) = True
isSolution notSolution = False


-- Finds position, length, and character represenation of a car that can be moved right
findNewRight :: String -> Char -> Int -> Int -> Int -> [(Char, Int, Int)] -> [(Char, Int, Int)]
-- below are the argument names
-- findNewRight currRow prevChar carLength carIndex currentIndex foundTuples

-- if get to empty list, return the information for movable cars found
findNewRight [] _ _ _ _ foundTuples = foundTuples
findNewRight ('-':cs) prevChar carLength carIndex currentIndex foundTuples
    | carLength > 1 = findNewRight cs '-' 0 0 (currentIndex + 1) ((prevChar, carLength, carIndex):foundTuples)
    | otherwise     = findNewRight cs '_' 0 0 (currentIndex + 1) foundTuples
findNewRight (c:cs) prevChar carLength carIndex currentIndex foundTuples
    | c == prevChar = findNewRight cs c (carLength + 1) carIndex     (currentIndex + 1) foundTuples
    | otherwise     = findNewRight cs c 1               currentIndex (currentIndex + 1) foundTuples

-- use a tuple returned by findNewRight to generate a new row
-- below are the argument names
-- newRow oldRow foundTuple index 
newRow :: String -> (Char, Int, Int) -> Int -> String
newRow [] _ _ = []
newRow (c:cs) (car, length, startIndex) currentIndex
  | currentIndex == startIndex = ('-':(newRow cs (car, length, startIndex) (currentIndex + 1)))
  | currentIndex > startIndex && currentIndex <= (startIndex + length)
                               = (car:(newRow cs (car, length, startIndex) (currentIndex + 1)))
  | otherwise                  = ( c :(newRow cs (car, length, startIndex) (currentIndex + 1)))


-- generating new move right states.
-- kinda brute forcing it, but whatev
generateNewRight :: [String] -> [[String]]
generateNewRight parentState = generateNewRightHelp [] parentState

-- pretty much appends new generated states from a row to generated states from previous rows
generateNewRightHelp :: [String] -> [String] -> [[String]]
generateNewRightHelp _ [] = []
generateNewRightHelp above (row:below)
    | null rowData = generateNewRightHelp (above ++ [row]) below
    | otherwise    = (rowsToState rowData above row below) ++ (generateNewRightHelp (above ++ [row]) below)
    where rowData = findNewRight row '-' 0 0 0 []

-- generates new states generated by a row 
rowsToState :: [(Char, Int, Int)] -> [String] -> String -> [String] -> [[String]]
rowsToState [] _ _ _ = []
rowsToState (t:ts) above row below = (above ++ [(newRow row t 0)] ++ below):(rowsToState ts above row below)

-- makes sure no cycles in search tree
-- trimDuplicates newStates path
trimDuplicates :: [[String]] -> [[String]] -> [[String]]
trimDuplicates [] _ = []
trimDuplicates (state:ss) path
    | elem state path = trimDuplicates ss path
    | otherwise       = state:(trimDuplicates ss path)

-- probably can use map for these, but lol
mirrorState :: [String] -> [String]
mirrorState [] = []
mirrorState (h:t) = (reverse h):(mirrorState t)

mirrorAllStates :: [[String]] -> [[String]]
mirrorAllStates [] = []
mirrorAllStates (h:t) = (mirrorState h):(mirrorAllStates t)


generateNewLeft :: [String] -> [[String]]
generateNewLeft parentState = mirrorAllStates (generateNewRight (mirrorState parentState))
-- could have instead writting as follows
-- generateNewLeft parentState = map (map reverse) (generateNewRight (map reverse parentState))


-- this doesn't seem to be alredy imported in my terminal for some reason
-- so i'm copying the source code for transpose here
transpose               :: [[a]] -> [[a]]
transpose []             = []
transpose ([]   : xss)   = transpose xss
transpose ((x:xs) : xss) = (x : [h | (h:_) <- xss]) : transpose (xs : [ t | (_:t) <- xss])

generateNewDown :: [String] -> [[String]]
generateNewDown parentState = map transpose (generateNewRight (transpose parentState))

generateNewUp :: [String] -> [[String]]
generateNewUp parentState = map transpose (generateNewLeft (transpose parentState))
